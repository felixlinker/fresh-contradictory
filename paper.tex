\PassOptionsToPackage{svgnames}{xcolor}
\documentclass[nonacm,natbib=false]{acmart}

\usepackage{graphicx}
\usepackage[inline]{enumitem}
\usepackage{listings}
\usepackage{ebproof}
\usepackage[acronym]{glossaries}
\usepackage{hyperref}
% \hypersetup{
% 	bookmarksdepth = 1,
% 	colorlinks = {true},
% 	citecolor = {ForestGreen},
% 	linkcolor={ForestGreen},
% 	urlcolor={gray},
% }
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{subcaption}

\lstset{basicstyle=\normalfont\ttfamily\small}

\usepackage[sortcites,style=numeric-comp,maxbibnames=99, maxcitenames=99]{biblatex}
\addbibresource{references.bib}

%chsp: there is already \negnf{} for the negation normal form
%\newcommand{\NNF}{\ensuremath{\text{\normalshape\sffamily NF}_\neg}}
\newcommand{\branch}[0]{\ensuremath{\mathrel{\|}}}
\newcommand{\bigbranch}[0]{\ensuremath{\big\|}}

\newcommand{\tmp}{\ensuremath{\mathit{tmp}}}
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\pub}{\ensuremath{\mathit{pub}}}
\newcommand{\fresh}{\ensuremath{\mathit{fresh}}}
\newcommand{\sortnat}{\ensuremath{\mathit{nat}}}
\newcommand{\lfacts}{\ensuremath{\textsf{lfacts}}}
\newcommand{\pfacts}{\ensuremath{\textsf{pfacts}}}

\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\rat}{\ensuremath{\mathbb{Q}}}
\newcommand{\cnstrs}{\ensuremath{\mathbb{C}}}
\newcommand{\vars}{\ensuremath{\mathcal{V}}}
\newcommand{\consts}{\ensuremath{\mathcal{C}}}
\newcommand{\tvar}{\ensuremath{\vars_{\tmp}}}
\newcommand{\msgvar}{\ensuremath{\vars_{\msg}}}
\newcommand{\pubvar}{\ensuremath{\vars_{\pub}}}
\newcommand{\substs}{\ensuremath{\mathbb{S}}}
\newcommand{\ofsort}[2]{\ensuremath{#1{:}#2}}
\newcommand{\const}[1]{\text{`\ensuremath{#1}'}}
\newcommand{\fr}{\text{\textasciitilde}}

\newcommand{\fv}{\ensuremath{\mathit{fv}}}

\newcommand{\edge}{\ensuremath{\rightarrowtail}}
\newcommand{\fact}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\factat}{\ensuremath{\vartriangleright}}
\newcommand{\chain}{\ensuremath{\dashrightarrow}}
\newcommand{\code}[1]{\ensuremath{\text{\sffamily #1}}}
\newcommand{\rto}{\ensuremath{\to^*}}
\newcommand{\lrule}[1]{\ensuremath{\mathrel{-\mkern-4mu[#1]\mkern-8mu\to}}}
\newcommand{\prems}{\ensuremath{\mathit{prems}}}
\newcommand{\acts}{\ensuremath{\mathit{acts}}}
\newcommand{\concs}{\ensuremath{\mathit{concs}}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\dgraphs}{\ensuremath{\mathit{dgraphs}}}
\newcommand{\idx}{\ensuremath{\mathit{idx}}}
\newcommand{\BC}{\ensuremath{\textsc{BC}}}
\newcommand{\IH}{\ensuremath{\textsc{IH}}}
\newcommand{\R}{\ensuremath{\mathcal{R}}}

\newcommand{\RFresh}[0]{\ensuremath{\textsc{Fresh}}}
\newcommand{\K}[0]{\ensuremath{\fact{K}}}
\newcommand{\Kup}[0]{\ensuremath{\fact{!K}^{\uparrow}}}
\newcommand{\Kdown}[0]{\ensuremath{\fact{!K}^{\downarrow}}}
\newcommand{\Fr}{\fact{Fr}}
\newcommand{\In}{\fact{In}}
\newcommand{\Out}{\fact{Out}}

\newcommand{\CSR}[1]{\ensuremath{\mathcal{S}_{#1}}}
\newcommand{\CSRST}[1]{\CSR{\mathsf{\uppercase{#1}}}}
\newcommand{\CSRDG}[1]{\ensuremath{\mathcal{DG}_{#1}}}
\newcommand{\CSRN}[1]{\ensuremath{{\mathcal{N}{#1}}}}
\newcommand{\SPrem}{\CSR{\textbf{Prem}}}
\newcommand{\SEdge}{\CSR{\edge}}
\newcommand{\SUnif}{\CSR{\approx}}
\newcommand{\SCyc}{\CSR{\circlearrowleft}}
\newcommand{\SCycBot}{\CSR{\circlearrowleft,\bot}}
\newcommand{\SBot}{\CSR{\bot}}
\newcommand{\SWeaken}{\CSR{W}}
\newcommand{\SCut}{\CSR{\Delta}}
\newcommand{\ginstRules}{\ensuremath{\lceil P \rceil^{\mathcal{RDH}_e}_{insts}}}
\newcommand{\ginstRulesSend}{\ensuremath{\ginstRules \cup \{ \textsc{SEND} \}}}

\newcommand{\sols}{\mathit{sols}}    % solutions
\newcommand{\factsig}{\ensuremath{\Sigma_\mathit{Fact}}}
\newcommand{\ts}{\ensuremath{\mathcal{T}}}

\newcommand{\dom}{\mathrm{dom}}
\newcommand{\map}{\rightharpoonup}
\newcommand{\fun}{\rightarrow}
\newcommand{\setof}{\mathrm{set}}
\newcommand{\setc}[2]{\{ #1 \mid #2 \}}
\newcommand{\idrel}{\mathrm{Id}}
\newcommand{\normf}{\ensuremath{{\downarrow}_{AX}}}
\newcommand{\variants}[1]{\ensuremath{\lceil #1 \rceil}_{AX}}

\newcommand{\limplies}{\Longrightarrow}
\newcommand{\negnf}[1]{\widehat{#1}}

\newcommand{\tsat}[1]{\vDash_{#1}}
\newcommand{\tsatE}{\tsat{E}}
\newcommand{\tr}{\mathit{tr}}

\newtheorem{definition}{Definition}
\newtheorem{lem}{Lemma}
\newtheorem*{lem*}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem*{thm*}{Theorem}
\newtheorem{cor}{Corollary}
\newtheorem{prop}{Proposition}
\newtheorem*{prop*}{Proposition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}

\begin{document}
\pagestyle{plain}

\title{Rule Variant Restrictions for the Tamarin Prover}

\author{Felix Linker}
\affiliation{%
  \institution{Department of Computer Science, ETH Zurich}
  \city{ZÃ¼rich}
  \country{Switzerland}}
\email{flinker@inf.ethz.ch}

\maketitle

\section{Introduction}

The Tamarin prover \cite{CAVtamarin,CSFtamarin} is a model checker for security protocol verification, which incorporates a constraint solving algorithm based on symbolic backwards search.
It was originally introduced in two doctoral theses \cite{TamarinThesisInduction,TamarinThesisConstraintSolving}.
Tamarin operates in the so-called \emph{symbolic model} were cryptographic messages are represented by terms, and cryptographic operations by equations on these terms.
The set of equations of a Tamarin theory are the theory's equational theory, and all reasoning happens modulo this equational theory.
Tamarin only considers equational theories with specific properties.
These properties allow Tamarin to:
\begin{enumerate}
  \item represent all terms in a unique normal form, and
  \item reason modulo the equational theory by considering finite sets of \emph{variants} of terms.
\end{enumerate}

These variants of terms are computed in a pre-computation phase.
In this paper, we introduce a pruning mechanism for variants that significantly reduces Tamarin's search space and prove this mechanism's soundness.
We experienced significant performance improvements when using this pruning mechanism, in particular when modelling protocols that use Diffie-Hellman group operators.

The purpose of this paper is to document this optimization, in particular, its soundness proof for the maintenance of the Tamarin prover.
As of publishing, our optimizations have already been integrated into Tamarin's code base.\footnote{%
  See \url{https://github.com/tamarin-prover/tamarin-prover/pull/763}.
}

\paragraph{Structure}

We proceed as follows.
We introduce relevant background in Section~\ref{sec:bg}.
Then, in Section~\ref{sec:theory}, we introduce our optimization and prove its soundness by relating it to a soundness proof in one of the original theses describing Tamarin.
We evaluate our optimization's performance in Section~\ref{sec:eval}.

\section{Background}
\label{sec:bg}

\input{bg.tex}

\section{Rule Variant Restrictions}
\label{sec:theory}

Our optimization applies to theories that use operators which can cancel out and thus have multiple variants attached to them.
Consider, for example, the following protocol rule using Diffie--Hellman exponentiation:
$$[  \Fr(\ofsort{x}{\fresh}), \In(m) ] \rightarrow [ \Out(m^x) ].$$

During precomputation, Tamarin will consider that exponentiation might cancel out, leading to the rule variant ($\circ^{-1}$ denotes an element's inverse):
$$[ \Fr(\ofsort{x}{\fresh}), \In(z^{\ofsort{x}{\fresh}^{-1}}) ] \rightarrow [ \Out(z) ].$$

It makes sense that Tamarin considers this variant during precomputation as it considers this rule in isolation.
However, when one additionally considers the semantics of Tamarin protocol models, one can see that this rule variant could never occur in a normal form dependency graph.
This is because the value that is used in the exponentiation, $\ofsort{x}{\fresh}$, is freshly introduced in this rule, but also required in the term $m$ received over the insecure network.
To construct this term, the sender must have had access to $\ofsort{x}{\fresh}$ before it was introduced, which is impossible.

In this section, we formalize the above intuition, and introduce \emph{fresh-contradictory variants}, that is, variants which need to use a fresh value before it was introduced.
We show that one need not consider such variants during proof search as the set of traces (normal form dependency graphs) admitted by a protocol model does not change when removing fresh-contradictory rule variants.

\begin{definition} \label{def:fresh-contradictory}
  Let $r = [ p_1, \dots, p_n] \lrule{\dots} [\dots]$ be a protocol rule and $\variants{r}^\R = \{(r_i, \tau_i)\}_{m \in \nat}$ a set of associated variants for a rewriting system $\R$ and associate and commutative equations $AX$.
  A variant $(r_i, \tau_i) \in \variants{r}^\R$ is \emph{fresh-contradictory} if $r$ has two distinct premises $p_i = \fact{F}(\dots, t, \dots)$ ($\fact{F} \neq \Fr$) and $p_j = \Fr(x)$ such that $x\tau_i \sqsubseteq t\tau_i \normf^\R$.
\end{definition}

We write $\variants{t}^{\R,\bot} \subseteq \variants{t}^\R$ for the fresh-contradictory variants of a term $t$.
Again, we extend this notion to multiset rewriting rules and sets of multiset rewriting rules.

\begin{lemma} \label{lem:ndg-eq}
  For every protocol model $(R, E)$ where $\R^\simeq \cup AX$ is an equational representation for $=_E$ and $AX$ only contains equations for associativity and commutativity:
  $$\{ dg\normf^\R \mid dg \in \dgraphs_{AX}(\variants{R}^\R) \} = \{ dg\normf^\R \mid dg \in \dgraphs_{AX}(\variants{R}^\R \setminus \variants{R}^{\R,\bot})\}.$$
\end{lemma}

\begin{proof}
  Let
  \begin{align*}
    NDG & := \{ dg\normf^\R \mid dg \in \dgraphs_{AX}(\variants{R}^\R) \} \\
    NDG_{\neg\bot} & := \{ dg\normf^\R \mid dg \in \dgraphs_{AX}(\variants{R}^\R \setminus \variants{R}^{\R,\bot})\}.
  \end{align*}
  It is clear that $NDG_{\neg\bot} \subseteq NDG$.
  We show that $NDG \subseteq NDG_{\neg\bot}$ by contradiction.
  Presume that there is a dependency graph $dg = (I, D) \in NDG \setminus NDG_{\neg\bot}$.
  By assumption, we know that all rule instances $ri \in I$ are $\normf^\R$-normal (as $dg$ is $\normf^\R$-normal).
  Thus, by the finite variant property, we know that for each rule instance $ri \in I$ there must be a rule variant $(r, \tau) \in \variants{R}^\R$ so that $ri =_{AX} r\sigma$ for some substitution $\sigma$ (note that $r$ is $\normf^\R$-normal by definition).
  There must be some rule instance $ri$ for which its associated variant $(r, \tau)$ (as per above) is in $\variants{R}^{\R,\bot}$.
  If not, $dg$ would be in $NDG_{\neg\bot}$.
  We fix such a rule instance $ri$ and associated variant $(r, \tau)$.

  As $r$ is a fresh-contradictory variant, there must be some fresh variable $x$ and term $t$ occurring in $r\sigma$ such that $x \sqsubseteq t\sigma$ and $x$ is introduced in $r$, i.e., $r\sigma$ has a $\Fr(x)$ premise.
  Observe that $x \sqsubseteq ri$ since $ri =_{AX} r\sigma$ and equations in $AX$ can never remove variables from a term.
  As $ri$ is $\normf^\R$-normal (cannot be reduced), $t$ in $ri$ must have been constructed using $x$.
  Therefore, there must be another rule instance that introduces $x$ as a fresh variable to construct $t$ and thus also contains a premise $\Fr(x)$.
  This, however, contradicts that instances of $\RFresh$ are unique.
\end{proof}

We can use this lemma to specialize Theorem~\ref{thm:reasoning-mod-ax} into the following one.

\begin{theorem} \label{thm:reasoning-mod-fresh}
    For every guarded trace property $\varphi$ and protocol model $(R, E)$ where $\R^\simeq \cup AX$ is an equational representation for $=_E$ and $AX$ only contains equations for associativity and commutativity:
    $$R \tsatE^\forall \varphi \iff \{ \trace(dg) \mid dg \in dgraphs_{AX}(\variants{R}^\R \setminus \variants{R}^{\R,\bot}), dg~\text{is}~\normf^\R\text{-normal} \} \tsat{AX}^\forall \varphi.$$
\end{theorem}

\begin{proof}
  Follows directly from Theorem~\ref{thm:reasoning-mod-ax} and Lemma~\ref{lem:ndg-eq}.
\end{proof}

Theorem~\ref{thm:reasoning-mod-fresh} allows us to prune all fresh-contradictory variants during Tamarin's precomputations.

\section{Evaluation}
\label{sec:eval}

\input{eval.tex}

\printbibliography

\end{document}
